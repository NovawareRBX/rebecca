

==== /commands/ping.ts ====

import { Command } from '@sapphire/framework';
import { MessageFlags } from 'discord.js';
import { createEmbed } from '../utilities/embed';
import emojis from '../utilities/emojis.json' assert { type: 'json' };

export class PingCommand extends Command {
  public constructor(context: Command.LoaderContext, options: Command.Options) {
    super(context, { ...options });
  }

  public override registerApplicationCommands(registry: Command.Registry) {
    registry.registerChatInputCommand(
      builder =>
        builder
          .setName('ping')
          .setDescription('Check bot latency and API response time'),
      {
        idHints: ['1361302221651972288'],
      }
    );
  }

  public override async chatInputRun(
    interaction: Command.ChatInputCommandInteraction
  ) {
    try {
      await interaction.deferReply({
        flags: MessageFlags.Ephemeral,
      });

      const reply = await interaction.fetchReply();
      const roundtripLatency =
        reply.createdTimestamp - interaction.createdTimestamp;
      const apiLatency = Math.round(this.container.client.ws.ping);

      const embed = createEmbed({
        title: `${emojis.checkmark} Pong!`,
        text: 'Latency and API response time',
        theme: 'success',
        fields: [
          {
            name: 'Bot Latency',
            value: `${roundtripLatency}ms`,
            inline: true,
          },
          {
            name: 'API Latency',
            value: `${apiLatency}ms`,
            inline: true,
          },
        ],
        timestamp: true,
      });

      return interaction.editReply({
        content: null,
        embeds: [embed],
      });
    } catch (error) {
      const errorEmbed = createEmbed({
        title: `${emojis.nocross} Error`,
        text: 'Failed to retrieve latency information.',
        theme: 'failure',
      });

      if (!interaction.replied) {
        return interaction.reply({
          embeds: [errorEmbed],
          flags: MessageFlags.Ephemeral,
        });
      }
      return interaction.editReply({
        embeds: [errorEmbed],
      });
    }
  }
}


==== /commands/sendSupportTicketEmbed.ts ====

import { Command } from '@sapphire/framework';
import {
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  EmbedBuilder,
  MessageFlags,
  PermissionFlagsBits,
} from 'discord.js';
import { createEmbed } from '../utilities/embed';
import emojis from '../utilities/emojis.json' assert { type: 'json' };

export class PingCommand extends Command {
  public constructor(context: Command.LoaderContext, options: Command.Options) {
    super(context, { ...options });
  }

  public override registerApplicationCommands(registry: Command.Registry) {
    registry.registerChatInputCommand(
      builder =>
        builder
          .setName('send-support-ticket-embed')
          .setDescription('Send a support ticket embed to the support channel')
          .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),
      {
        idHints: ['1361704488565604486'],
      }
    );
  }

  public override async chatInputRun(
    interaction: Command.ChatInputCommandInteraction
  ) {
    const embed = new EmbedBuilder()
      .setDescription(
        '## <:novawareemoji:1276797939074727948> Fortune Frenzy Support\n**Need help?** Click the button below to open a ticket and our team will get back to you as soon as possible.'
      )
      .setColor('#d0a955')
      .setFooter({
        text: 'Available 24/7. Please be kind to our staff.',
        iconURL:
          'https://cdn.discordapp.com/emojis/1252703372998611085.webp?size=96',
      });

    const button = new ButtonBuilder()
      .setCustomId('create-ticket')
      .setLabel('Create Ticket')
      .setEmoji("<:mail:1361707222056439947>")
      .setStyle(ButtonStyle.Secondary);

    const msgObject = {
      embeds: [embed],
      components: [new ActionRowBuilder<ButtonBuilder>().addComponents(button)],
    };

    if (interaction.channel?.isSendable()) {
      await interaction.channel.send(msgObject);
    } else {
      await interaction.reply({
        ...msgObject,
      });
    }
  }
}


==== /listeners/ready.ts ====

import { ApplyOptions } from '@sapphire/decorators';
import { Listener } from '@sapphire/framework';
import { ActivityType } from 'discord.js';

@ApplyOptions<Listener.Options>({ once: true })
export class ReadyListener extends Listener {
  public run() {
    this.container.logger.info(
      `Logged in as ${this.container.client.user?.tag}`
    );

    const user = this.container.client.user;
    if (!user) return;

    user.setPresence({
      activities: [
        {
          type: ActivityType.Custom,
          name: 'custom',
          state: 'dms open for support!',
        },
      ],
    });
  }
}


==== /index.ts ====

import { SapphireClient } from '@sapphire/framework';
import { GatewayIntentBits, Partials } from 'discord.js';

const client = new SapphireClient({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.DirectMessages,
  ],
  partials: [
    Partials.Message,
    Partials.Channel,
    Partials.GuildMember,
    Partials.Reaction,
  ],
  loadMessageCommandListeners: true,
});

client.login(process.env.DISCORD_KEY);

==== /utilities/embed.ts ====

import {
  EmbedBuilder,
  type ColorResolvable,
  type EmbedAuthorOptions,
  type EmbedFooterOptions,
  type EmbedField,
} from 'discord.js';

type EmbedTheme = 'success' | 'warning' | 'failure' | 'neutral';

interface EmbedOptions {
  text?: string;
  theme?: EmbedTheme;
  title?: string;
  author?: EmbedAuthorOptions;
  footer?: EmbedFooterOptions;
  fields?: EmbedField[];
  timestamp?: boolean | Date;
  thumbnail?: string;
  image?: string;
  url?: string;
  color?: ColorResolvable;
}

const themeColors: Record<EmbedTheme, ColorResolvable> = {
  success: '#38cc96', // Green
  warning: '#ffaa00', // Orange
  failure: '#df6461', // Red
  neutral: '#0099ff', // Blue
};

export function createEmbed(options: EmbedOptions): EmbedBuilder {
  const {
    text,
    theme = 'neutral',
    title,
    author,
    footer,
    fields,
    timestamp,
    thumbnail,
    image,
    url,
    color,
  } = options;

  const description = text
    ? title
      ? `### ${title}\n${text}`
      : text
    : title
      ? `### ${title}`
      : '';
  const embed = new EmbedBuilder()
    .setColor(color || themeColors[theme])
    .setDescription(description);

  if (author) embed.setAuthor(author);
  if (footer) embed.setFooter(footer);
  if (fields?.length) embed.addFields(fields);
  if (timestamp)
    embed.setTimestamp(timestamp === true ? new Date() : timestamp);
  if (thumbnail) embed.setThumbnail(thumbnail);
  if (image) embed.setImage(image);
  if (url) embed.setURL(url);

  return embed;
}


==== /utilities/emojis.json ====

{
    "checkmark": "<:checkmark:1361308061922365581>",
    "thumbsup": "<:thumbsup:1361308054754426981>",
    "nocross": "<:nocross:1361308038895632604>",

    "white_nocross": "<:Cross:1302340638691557406>",
    "white_checkmark": "<:Check:1302340568948412416>",

    "loading": "<a:loading:1362040450193690806>"
}

==== /utilities/openai.ts ====

import OpenAI from "openai";

const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function getOpenAI() {
  return client;  
}

==== /utilities/tickets/prompt.txt ====

Classify a user's text into one of four categories and provide a severity rating from 1 to 10, using the provided examples for determining severity.

Consider the following categories for classification:
- "general_support" for general questions and inquiries.
- "game issues" for any issues with the game, payment problems, bugs, etc.
- "user reports" for reporting other users for breaking rules, etc.
- "staff reports/management" for reporting members of staff and contacting seniors.  
  - *Note: Members of staff may be referred to as "mods," "moderators," "admins," "staff," etc., always put mod reports into management tickets no matter what.*

Additionally, determine the urgency or severity of the matter, providing a rating from 1 (least urgent) to 10 (most urgent). Severity depends on several factors, such as:
- Severity 1: Minor issues, e.g., someone being rude.
- Severity 10: Serious issues, e.g., major game glitch affecting the economy.

If you are unsure which category to assign or if the question is general, default to "general_support".

# Steps

1. **Understand the Content**: Analyze the user's text to understand the main subject, context, and intent.
2. **Classify the Text**: Based on the content, assign the most appropriate category out of the four options provided.
3. **Determine Severity**: Evaluate the urgency or severity of the issue discussed in the text and assign a rating between 1 and 10.

# Output Format

Provide the output in the following JSON format:
```json
{
  "category": "your_category_here",
  "severity": your_severity_rating_here
}
```

# Examples

**Example 1:**
- **Input**: "I paid for an item, but it hasn't been delivered in the game."
- **Output**:
  ```json
  {
    "category": "game issues",
    "severity": 7
  }
  ```

**Example 2:**
- **Input**: "I'd like to report someone for exploiting bugs in the game."
- **Output**:
  ```json
  {
    "category": "user reports",
    "severity": 6
  }
  ```

# Notes

- Ensure each text is thoroughly analyzed for accurate classification and severity rating.
- Consider context and implied urgency when assigning severity ratings.

==== /utilities/tickets/ticket_channels.json ====

{
    "channel_ids": {
        "general_support": "1361728934231670894",
        "game_issues": "1361337366937206888",
        "user_reports": "1361337436751269988",
        "staff_reports_management": "1361724113135210757"
    },
    "readable_names": {
        "general_support": "General Support",
        "game_issues": "Game Issues",
        "user_reports": "User Reports",
        "staff_reports_management": "Management"
    }
}

==== /utilities/tickets/category_welcome_msgs/general_support.txt ====

Hey {{PING}}! Thanks for reaching out to us. Our team will review your ticket shortly—please include as much info as you can so we can get your problem sorted quickly.

==== /utilities/tickets/category_welcome_msgs/game_issues.txt ====

Hey <@733707800345051216>! Thanks for letting us know something’s up. Our team will review your ticket shortly—please include as much info as you can so we can get it sorted quickly.

==== /utilities/tickets/category_welcome_msgs/user_reports.txt ====

Hey {{PING}}, thanks for your report! Our team will review it within 24–48 hours, but please note times may vary. To help us speed things up, please attach any evidence you have. 

While you wait, could you answer the following:
- What exactly happened?
- When did it occur (approximate date/time)?
- Who was involved (usernames)?

==== /utilities/tickets/category_welcome_msgs/staff_reports_management.txt ====

Hey {{PING}}, thanks for reaching out. This ticket has been flagged for management review. Reports involving staff (mods, admins, etc.) are taken seriously, and a senior team member will review your concerns shortly.

In the mean time, are you able to answer any of the following questions? It'll help a bunch:
- Which staff member are you reporting (username or role)?
- What happened, and when?
- Can you explain the situation in detail?
- Do you have any supporting evidence (screenshots, messages, etc.)?

==== /utilities/tickets/saveTranscript.ts ====

import {
  Client,
  Snowflake,
  TextChannel,
  FetchMessagesOptions,
  Message,
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
} from 'discord.js';
import { getMariaConnection } from '../../services/mariadb';
import { UTApi } from 'uploadthing/server';
import crypto from 'crypto';
import { createEmbed } from '../embed';
import data from './ticket_channels.json' assert { type: 'json' };

interface StrippedMessage {
  content: string;
  author: string;
  timestamp: Date;
  attachments: { url: string; name: string | null }[];
}

async function fetchAllMessages(channel: TextChannel): Promise<Message[]> {
  const allMessages: Message[] = [];
  let lastId: string | null = null;
  const limit = 100;

  try {
    while (true) {
      const options: FetchMessagesOptions = { limit };
      if (lastId) options.before = lastId;

      const messages = await channel.messages.fetch(options);
      allMessages.push(...messages.values());

      if (messages.size < limit) break;
      const lastMessage = messages.last();
      if (!lastMessage) break;
      lastId = lastMessage.id;
    }
  } catch (error) {
    console.error('Error fetching messages:', error);
    throw new Error('Failed to fetch messages from channel');
  }

  return allMessages.filter(message => !message.author.bot);
}

async function uploadAttachments(
  attachments: { url: string; name: string | null }[],
  utapi: UTApi
): Promise<Map<string, string>> {
  const urlToUfsUrl = new Map<string, string>();
  const attachmentUrls = attachments.map(att => att.url);

  try {
    const uploaded = await utapi.uploadFilesFromUrl(attachmentUrls);
    for (let i = 0; i < uploaded.length; i++) {
      const originalUrl = attachmentUrls[i];
      const ufsUrl = uploaded[i].data?.ufsUrl;
      if (ufsUrl) {
        urlToUfsUrl.set(originalUrl, ufsUrl);
      }
    }
  } catch (error) {
    console.error('Error uploading attachments:', error);
  }

  return urlToUfsUrl;
}

async function saveTranscript(
  channel_id: Snowflake,
  messages: StrippedMessage[]
) {
  const transcriptId = crypto
    .randomBytes(6)
    .toString('base64')
    .replace(/[^a-zA-Z0-9]/g, '')
    .slice(0, 10);

  const maria = await getMariaConnection();
  await maria.query(
    'INSERT INTO ticket_transcripts (transcript_id, messages, related_channel_id) VALUES (?, ?, ?)',
    [transcriptId, JSON.stringify(messages), channel_id]
  );

  return transcriptId;
}

async function logNewTranscript(
  client: Client,
  channel_id: Snowflake,
  transcript_id: string
) {
  const channel = await client.channels.fetch('1362559684841574501');
  if (!channel || !(channel instanceof TextChannel)) {
    throw new Error('Invalid or inaccessible channel');
  }

  const maria = await getMariaConnection();
  const [ticket] = await maria.query(
    'SELECT * FROM support_tickets WHERE channel_id = ?',
    [channel_id]
  );

  const ticket_channel = await client.channels.fetch(ticket.channel_id);
  const customer = await client.users.fetch(ticket.customer_id);
  if (!ticket_channel || !(ticket_channel instanceof TextChannel)) {
    throw new Error('Invalid or inaccessible channel');
  }

  if (channel.isSendable()) {
    const message = await channel.send({
      embeds: [
        createEmbed({
          theme: 'success',
          title: `New Transcript Saved`,
          text: `The Transcript for ${data.readable_names[ticket.category as keyof typeof data.readable_names]} Ticket #${ticket.ticket_number.toString().padStart(4, '0')} has been saved`,
          fields: [
            {
              name: 'Ticket Owner',
              value: `<@${ticket.customer_id}>`,
              inline: true,
            },
            {
              name: 'Ticket Name',
              value: ticket_channel.name,
              inline: true,
            },
            {
              name: 'Ticket Category',
              value:
                data.readable_names[
                  ticket.category as keyof typeof data.readable_names
                ],
              inline: true,
            },
            {
              name: 'Transcript ID',
              value: transcript_id,
              inline: true,
            },
            {
              name: 'Ticket Claimer',
              value: ticket.staff_id ? `<@${ticket.staff_id}>` : 'No one',
              inline: true,
            },
          ],
          author: {
            name: customer.username,
            iconURL: customer.displayAvatarURL(),
          },
          timestamp: new Date(),
        }),
      ],
      components: [
        new ActionRowBuilder<ButtonBuilder>().addComponents(
          new ButtonBuilder({
            label: 'View Transcript',
            style: ButtonStyle.Link,
            url: `https://trcs.frazers.co/${transcript_id}`,
          })
        ),
      ],
    });

    await maria.query(
      'UPDATE support_tickets SET transcript_message_id = ? WHERE channel_id = ?',
      [message.id, channel_id]
    );
  }

  maria.release();
}

export default async function (
  client: Client,
  channel_id: Snowflake
): Promise<string> {
  const channel = await client.channels.fetch(channel_id);
  if (!channel || !(channel instanceof TextChannel)) {
    throw new Error('Invalid or inaccessible channel');
  }

  const messages = await fetchAllMessages(channel);
  const stripped: StrippedMessage[] = messages.map(message => ({
    content: message.content,
    author: message.author.id,
    timestamp: message.createdAt,
    attachments: message.attachments.map(attachment => ({
      url: attachment.url,
      name: attachment.name,
    })),
  }));

  const allAttachments = stripped.flatMap(message => message.attachments);
  if (allAttachments.length === 0) {
    const transcriptId = await saveTranscript(channel_id, stripped);
    logNewTranscript(client, channel_id, transcriptId);
    return transcriptId;
  }

  const utapi = new UTApi();
  const urlToUfsUrl = await uploadAttachments(allAttachments, utapi);
  for (const message of stripped) {
    for (const attachment of message.attachments) {
      const newUrl = urlToUfsUrl.get(attachment.url);
      if (newUrl) {
        attachment.url = newUrl;
      }
    }
  }

  const transcriptId = await saveTranscript(channel_id, stripped);
  logNewTranscript(client, channel_id, transcriptId);
  return transcriptId;
}


==== /services/mariadb.ts ====

import mariadb from "mariadb";

let pools: { [key: string]: mariadb.Pool } = {};
type DatabaseName = "NovawareDiscord" | "Game1";

const credentials = {
	NovawareDiscord: [process.env.DISCORD_MARIADB_USER, process.env.DISCORD_MARIADB_PASSWORD],
	Game1: [process.env.GAME1_MARIADB_USER, process.env.GAME1_MARIADB_PASSWORD],
};

function initializePool(database: DatabaseName): void {
	if (credentials[database] === undefined) {
		console.error(`No credentials found for ${database}`);
		return;
	}

	pools[database] = mariadb.createPool({
		host: "172.18.0.4",
		port: 6033,
		user: credentials[database][0],
		password: credentials[database][1],
		database: database,
		connectionLimit: 30,
	});
}

export async function getMariaConnection(database: DatabaseName = "NovawareDiscord") {
	if (!pools[database]) {
		initializePool(database);
	}
	return pools[database].getConnection();
}


==== /services/redis.ts ====

import { createClient, RedisClientType } from 'redis';

let client: RedisClientType;

async function initialize(): Promise<void> {
  client = createClient({
    url: 'redis://172.18.0.5:6379',
    password: process.env.REDIS_PASSWORD,
    socket: {
      host: '172.18.0.5',
      port: 6379,
      tls: false,
    },
    database: 0,
    commandsQueueMaxLength: 1000,
  });

  client.on('error', error => {
    console.error('Redis Client Error:', error);
  });

  await client.connect();
}

export async function getRedisConnection(): Promise<RedisClientType> {
  if (!client) {
    await initialize();
  }

  return client;
}

==== /services/ai/AIService.ts ====

import { getOpenAI } from '../../utilities/openai';
import prompt from '../../utilities/tickets/prompt.txt';

export async function getCategoryAndSeverity(text: string): Promise<{
  category:
    | 'general_support'
    | 'game_issues'
    | 'user_reports'
    | 'staff_reports_management';
  severity: number;
} | null> {
  const openai = await getOpenAI();

  const chatCompletion = await openai.chat.completions.create({
    model: 'gpt-4o-mini',
    messages: [
      {
        role: 'system',
        content: prompt,
      },
      {
        role: 'user',
        content: text,
      },
    ],
    response_format: {
      type: 'json_schema',
      json_schema: {
        name: 'category_response',
        strict: true,
        schema: {
          type: 'object',
          properties: {
            category: {
              type: 'string',
              description: "The category of the user's text.",
              enum: [
                'general_support',
                'game_issues',
                'user_reports',
                'staff_reports_management',
              ],
            },
            severity: {
              type: 'number',
              description:
                'Severity or urgency rating on a scale from 1 to 10.',
            },
          },
          required: ['category', 'severity'],
          additionalProperties: false,
        },
      },
    },
  });

  const content = chatCompletion.choices[0].message.content;
  if (!content) return null;
  const json = JSON.parse(content);
  if (json.category && json.severity) {
    return {
      category: json.category,
      severity: json.severity,
    };
  }

  return null;
}


==== /interaction-handlers/modals/tickets/createTicketModal.ts ====

import {
  InteractionHandler,
  InteractionHandlerTypes,
} from '@sapphire/framework';
import {
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  MessageFlags,
  type ModalSubmitInteraction,
} from 'discord.js';
import { getCategoryAndSeverity } from '../../../services/ai/AIService';
import { createEmbed } from '../../../utilities/embed';
import emojis from '../../../utilities/emojis.json' assert { type: 'json' };
import ticketChannels from '../../../utilities/tickets/ticket_channels.json';
import { getMariaConnection } from '../../../services/mariadb';

import generalSupportWelcomeMsg from '../../../utilities/tickets/category_welcome_msgs/general_support.txt';
import gameIssuesWelcomeMsg from '../../../utilities/tickets/category_welcome_msgs/game_issues.txt';
import userReportsWelcomeMsg from '../../../utilities/tickets/category_welcome_msgs/user_reports.txt';
import staffReportsManagementWelcomeMsg from '../../../utilities/tickets/category_welcome_msgs/staff_reports_management.txt';

const welcomeMsgs = {
  general_support: generalSupportWelcomeMsg,
  game_issues: gameIssuesWelcomeMsg,
  user_reports: userReportsWelcomeMsg,
  staff_reports_management: staffReportsManagementWelcomeMsg,
};

export class CreateTicketModalHandler extends InteractionHandler {
  public constructor(
    ctx: InteractionHandler.LoaderContext,
    options: InteractionHandler.Options
  ) {
    super(ctx, {
      ...options,
      interactionHandlerType: InteractionHandlerTypes.ModalSubmit,
    });
  }

  public override parse(interaction: ModalSubmitInteraction) {
    if (interaction.customId !== 'create-ticket-modal') return this.none();
    return this.some();
  }

  public async run(interaction: ModalSubmitInteraction) {
    await interaction.deferReply({ flags: MessageFlags.Ephemeral });
    const problemDescription = interaction.fields.getTextInputValue(
      'problem-description'
    );
    const categoryAndSeverity =
      await getCategoryAndSeverity(problemDescription);
    if (!categoryAndSeverity) {
      await interaction.editReply({
        embeds: [
          createEmbed({
            theme: 'failure',
            title: `${emojis.nocross} Error`,
            text: 'Something went wrong, please try again later.',
          }),
        ],
      });
      return;
    }

    const { category, severity } = categoryAndSeverity;
    const parentChannelId = ticketChannels.channel_ids[category];
    const maria = await getMariaConnection('NovawareDiscord');

    await maria.query(
      'INSERT INTO ticket_counters (category, counter) VALUES (?, 1) ON DUPLICATE KEY UPDATE counter = counter + 1',
      [category]
    );

    const result = await maria.query(
      'SELECT counter FROM ticket_counters WHERE category = ?',
      [category]
    );

    const ticketNumber = result[0].counter.toString().padStart(4, '0');

    const channel = await interaction.guild?.channels.create({
      name: `ticket-${ticketNumber}`,
      parent: parentChannelId,
    });

    if (!channel) {
      maria.release();
      return await interaction.editReply({
        embeds: [
          createEmbed({
            theme: 'failure',
            title: `${emojis.nocross} Error`,
            text: 'Something went wrong, please try again later.',
          }),
        ],
      });
    }

    const initialMessage = await channel.send({
      content: `<@${interaction.user.id}> <@&1361789304187261049>`,
      embeds: [
        createEmbed({
          text: `${welcomeMsgs[category].replace(
            '{{PING}}',
            `<@${interaction.user.id}>`
          )}\n\n**You said:**\n${problemDescription}`,
          theme: 'success',
          color: "#D0A955",
          footer: {
            iconURL: interaction.user.displayAvatarURL(),
            text: `${interaction.user.username}`,
          },
          timestamp: true,
        }),
      ],
      components: [
        new ActionRowBuilder<ButtonBuilder>().addComponents(
          new ButtonBuilder()
            .setCustomId('close-ticket')
            .setLabel('Close')
            .setEmoji(emojis.white_nocross)
            .setStyle(ButtonStyle.Secondary),
          new ButtonBuilder()
            .setCustomId('claim-ticket')
            .setLabel('Claim')
            .setEmoji(emojis.white_checkmark)
            .setStyle(ButtonStyle.Secondary),
        ),
      ],
    });

    channel.permissionOverwrites.edit(interaction.user, {
      ViewChannel: true,
      SendMessages: true,
      ReadMessageHistory: true,
      AttachFiles: true,
      EmbedLinks: true,
      AddReactions: true,
    });

    await interaction.editReply({
      embeds: [
        createEmbed({
          title: `${emojis.checkmark} Ticket Created`,
          text: `You can access it here: <#${channel.id}>`,
          theme: 'success',
        }),
      ],
    });

    await maria.query(
      "INSERT INTO support_tickets (customer_id, category, channel_id, ticket_number, initial_message_id) VALUES (?, ?, ?, ?, ?)",
      [interaction.user.id, category, channel.id, ticketNumber, initialMessage.id]
    );

    maria.release();
  }
}


==== /interaction-handlers/modals/tickets/reviewTicketModal.ts ====

import {
  InteractionHandler,
  InteractionHandlerTypes,
} from '@sapphire/framework';
import {
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  MessageFlags,
  TextChannel,
  type ModalSubmitInteraction,
} from 'discord.js';
import { getCategoryAndSeverity } from '../../../services/ai/AIService';
import { createEmbed } from '../../../utilities/embed';
import emojis from '../../../utilities/emojis.json' assert { type: 'json' };
import ticketChannels from '../../../utilities/tickets/ticket_channels.json';
import { getMariaConnection } from '../../../services/mariadb';

import generalSupportWelcomeMsg from '../../../utilities/tickets/category_welcome_msgs/general_support.txt';
import gameIssuesWelcomeMsg from '../../../utilities/tickets/category_welcome_msgs/game_issues.txt';
import userReportsWelcomeMsg from '../../../utilities/tickets/category_welcome_msgs/user_reports.txt';
import staffReportsManagementWelcomeMsg from '../../../utilities/tickets/category_welcome_msgs/staff_reports_management.txt';

const welcomeMsgs = {
  general_support: generalSupportWelcomeMsg,
  game_issues: gameIssuesWelcomeMsg,
  user_reports: userReportsWelcomeMsg,
  staff_reports_management: staffReportsManagementWelcomeMsg,
};

export class CreateTicketModalHandler extends InteractionHandler {
  public constructor(
    ctx: InteractionHandler.LoaderContext,
    options: InteractionHandler.Options
  ) {
    super(ctx, {
      ...options,
      interactionHandlerType: InteractionHandlerTypes.ModalSubmit,
    });
  }

  public override parse(interaction: ModalSubmitInteraction) {
    return interaction.customId.startsWith('review-ticket-modal-')
      ? this.some()
      : this.none();
  }

  public async run(interaction: ModalSubmitInteraction) {
    const ticketId = interaction.customId.split('-')[3];
    const rating = interaction.fields.getTextInputValue('rating');
    const comment = interaction.fields.getTextInputValue('comment');

    if (isNaN(Number(rating)))
      return interaction.reply({
        embeds: [
          createEmbed({
            theme: 'failure',
            title: `${emojis.nocross} Error`,
            text: 'Your rating must be a number between 1 and 5!',
          }),
        ],
        flags: MessageFlags.Ephemeral,
      });

    // check if the review already exists
    const maria = await getMariaConnection();
    const [review] = await maria.query(
      'SELECT * FROM support_ticket_ratings WHERE ticket_id = ?',
      [ticketId]
    );
    if (review) {
      maria.release();
      return interaction.reply({
        embeds: [
          createEmbed({
            theme: 'failure',
            title: `${emojis.nocross} Error`,
            text: 'You have already reviewed this ticket!',
          }),
        ],
        flags: MessageFlags.Ephemeral,
      });
    }

    const [ticket] = await maria.query(
      'SELECT * FROM support_tickets WHERE id = ?',
      [ticketId]
    );

    if (!ticket) {
      maria.release();
      return interaction.reply({
        embeds: [
          createEmbed({
            theme: 'failure',
            title: `${emojis.nocross} Error`,
            text: 'Ticket not found!',
          }),
        ],
        flags: MessageFlags.Ephemeral,
      });
    }

    // insert the review
    await maria.query(
      'INSERT INTO support_ticket_ratings (ticket_id, rating, review) VALUES (?, ?, ?)',
      [ticketId, rating, comment]
    );
    maria.release();
    interaction.reply({
      embeds: [
        createEmbed({
          theme: 'success',
          title: `${emojis.checkmark} Review submitted`,
          text: 'Thank you for your feedback!',
        }),
      ],
      flags: MessageFlags.Ephemeral,
    });

    const channel = (await interaction.client.channels.fetch(
      '1362559684841574501'
    )) as TextChannel;
    const transcript_message = await channel.messages.fetch(
      ticket.transcript_message_id
    );

    if (transcript_message) {
      const embed = transcript_message.embeds[0];
      embed.fields.push({
        name: 'Review',
        value: `Rating: ${rating}\nReview: ${comment}`,
        inline: false,
      });
      await transcript_message.edit({ embeds: [embed] });
    }
  }
}


==== /interaction-handlers/buttons/tickets/createTicketButton.ts ====

import {
  InteractionHandler,
  InteractionHandlerTypes,
} from '@sapphire/framework';
import {
  ActionRowBuilder,
  ModalBuilder,
  TextInputBuilder,
  TextInputStyle,
  type ButtonInteraction,
  GuildMember,
  MessageFlags,
} from 'discord.js';
import { createEmbed } from '../../../utilities/embed';
import emojis from '../../../utilities/emojis.json' assert { type: 'json' };

export class CreateTicketButton extends InteractionHandler {
  public constructor(
    ctx: InteractionHandler.LoaderContext,
    options: InteractionHandler.Options
  ) {
    super(ctx, {
      ...options,
      interactionHandlerType: InteractionHandlerTypes.Button,
    });
  }

  public override parse(interaction: ButtonInteraction) {
    if (interaction.customId !== 'create-ticket') return this.none();
    return this.some();
  }

  public async run(interaction: ButtonInteraction) {
    const requiredRole = '1180093268025950338';
    const member = interaction.member as GuildMember;

    if (!member || !(member instanceof GuildMember)) {
      return await interaction.reply({
        embeds: [
          createEmbed({
            theme: 'failure',
            title: `${emojis.nocross} Error`,
            text: 'Something went wrong, please try again later.',
          }),
        ],
        flags: [MessageFlags.Ephemeral],
      });
    }

    if (!member.roles.cache.has(requiredRole)) {
      return await interaction.reply({
        embeds: [
          createEmbed({
            theme: 'failure',
            title: `${emojis.nocross} Error`,
            text: 'Tickets are not available to the public yet. Please contact a staff member if you need help.',
          }),
        ],
        flags: [MessageFlags.Ephemeral],
      });
    }

    await interaction.showModal(
      new ModalBuilder()
        .setCustomId('create-ticket-modal')
        .setTitle('Create Ticket')
        .addComponents(
          new ActionRowBuilder<TextInputBuilder>().addComponents(
            new TextInputBuilder()
              .setCustomId('problem-description')
              .setLabel('What is the problem?')
              .setStyle(TextInputStyle.Paragraph)
          )
        )
    );
  }
}


==== /interaction-handlers/buttons/tickets/claimTicketButton.ts ====

import {
  InteractionHandler,
  InteractionHandlerTypes,
} from '@sapphire/framework';
import { type ButtonInteraction, GuildMember, TextChannel } from 'discord.js';
import { createEmbed } from '../../../utilities/embed';
import emojis from '../../../utilities/emojis.json' assert { type: 'json' };
import { getMariaConnection } from '../../../services/mariadb';

export class ClaimTicketButton extends InteractionHandler {
  private readonly requiredRole = '1277325690664124428';

  public constructor(
    ctx: InteractionHandler.LoaderContext,
    options: InteractionHandler.Options
  ) {
    super(ctx, {
      ...options,
      interactionHandlerType: InteractionHandlerTypes.Button,
    });
  }

  public override parse(interaction: ButtonInteraction) {
    return interaction.customId === 'claim-ticket' ? this.some() : this.none();
  }

  public async run(interaction: ButtonInteraction) {
    const member = interaction.member as GuildMember;

    if (!member || !(member instanceof GuildMember)) {
      return this.replyError(
        interaction,
        'Something went wrong, please try again later.'
      );
    }

    if (!member.roles.cache.has(this.requiredRole)) {
      return this.replyError(
        interaction,
        'Only staff members can claim tickets.'
      );
    }

    await interaction.deferUpdate();

    const maria = await getMariaConnection();
    const [ticket] = await maria.query(
      'SELECT * FROM support_tickets WHERE channel_id = ?',
      [interaction.channel?.id]
    );

    if (!ticket) {
      maria.release();
      return this.replyError(interaction, 'This is not a valid ticket.');
    }

    await this.handlePreviousMessage(interaction, ticket.claimed_message_id);

    const isClaimedByUser = ticket.staff_id === member.id;
    const action = isClaimedByUser ? 'unclaim' : 'claim';

    await this.updateTicket(maria, interaction, member, action);
    const newMessage = await this.sendTicketMessage(
      interaction,
      member,
      action
    );

    if (newMessage) {
      await maria.query(
        'UPDATE support_tickets SET claimed_message_id = ? WHERE channel_id = ?',
        [newMessage.id, interaction.channel?.id]
      );
    }

    maria.release();

    await this.updateChannelName(interaction, member, ticket, action);
  }

  private async replyError(interaction: ButtonInteraction, text: string) {
    await interaction.reply({
      embeds: [
        createEmbed({
          theme: 'failure',
          title: `${emojis.nocross} Error`,
          text,
        }),
      ],
      ephemeral: true,
    });
  }

  private async handlePreviousMessage(
    interaction: ButtonInteraction,
    messageId: string | null
  ) {
    if (messageId && interaction.channel) {
      try {
        const previousMessage =
          await interaction.channel.messages.fetch(messageId);
        await previousMessage.delete();
      } catch (error) {
        console.error('Failed to delete previous message:', error);
      }
    }
  }

  private async updateTicket(
    maria: any,
    interaction: ButtonInteraction,
    member: GuildMember,
    action: 'claim' | 'unclaim',
  ) {
    const query =
      action === 'unclaim'
        ? 'UPDATE support_tickets SET staff_id = NULL, claimed_at = NULL, claimed_message_id = NULL WHERE channel_id = ?'
        : 'UPDATE support_tickets SET staff_id = ?, claimed_at = NOW(), claimed_message_id = NULL WHERE channel_id = ?';
    const params =
      action === 'unclaim'
        ? [interaction.channel?.id]
        : [member.id, interaction.channel?.id];

    await maria.query(query, params);
  }

  private async sendTicketMessage(
    interaction: ButtonInteraction,
    member: GuildMember,
    action: 'claim' | 'unclaim'
  ) {
    if (!interaction.channel?.isSendable()) return null;

    const isClaim = action === 'claim';
    return await interaction.channel.send({
      embeds: [
        createEmbed({
          theme: isClaim ? 'success' : 'failure',
          title: `${isClaim ? emojis.checkmark : emojis.nocross} Ticket ${isClaim ? 'Claimed' : 'Unclaimed'}`,
          text: `<@${member.id}> has ${isClaim ? 'claimed' : 'unclaimed'} the ticket.`,
        }),
      ],
    });
  }

  private async updateChannelName(
    interaction: ButtonInteraction,
    member: GuildMember,
    ticket: any,
    action: 'claim' | 'unclaim'
  ) {
    if (
      !interaction.channel?.isDMBased() &&
      interaction.channel?.isTextBased()
    ) {
      const channel = interaction.channel as TextChannel;
      const ticketNumber = ticket.ticket_number.toString().padStart(4, '0');
      const newName =
        action === 'unclaim'
          ? `ticket-${ticketNumber}`
          : `${member.user.username}-${ticketNumber}`;
      await channel.setName(newName);
    }
  }
}


==== /interaction-handlers/buttons/tickets/closeTicketButton.ts ====

import {
  InteractionHandler,
  InteractionHandlerTypes,
} from '@sapphire/framework';
import {
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  GuildTextBasedChannel,
  MessageFlags,
  TextChannel,
  type ButtonInteraction,
} from 'discord.js';
import { createEmbed } from '../../../utilities/embed';
import emojis from '../../../utilities/emojis.json' assert { type: 'json' };
import { getMariaConnection } from '../../../services/mariadb';
import saveTranscript from '../../../utilities/tickets/saveTranscript';

export class CreateTicketButton extends InteractionHandler {
  public constructor(
    ctx: InteractionHandler.LoaderContext,
    options: InteractionHandler.Options
  ) {
    super(ctx, {
      ...options,
      interactionHandlerType: InteractionHandlerTypes.Button,
    });
  }

  public override parse(interaction: ButtonInteraction) {
    return interaction.customId === 'close-ticket' ||
      interaction.customId === 'confirm-close-ticket' ||
      interaction.customId === 'cancel-close-ticket'
      ? this.some()
      : this.none();
  }

  public async run(interaction: ButtonInteraction) {
    if (interaction.customId === 'close-ticket') {
      await this.closePreConfirm(interaction);
    } else if (interaction.customId === 'confirm-close-ticket') {
      await this.closeConfirm(interaction);
    } else if (interaction.customId === 'cancel-close-ticket') {
      await this.cancelClose(interaction);
    }
  }

  private async closeConfirm(interaction: ButtonInteraction) {
    await interaction.deferUpdate();

    const maria = await getMariaConnection();
    const channel = interaction.channel as TextChannel;
    const [ticket] = await maria.query(
      'SELECT * FROM support_tickets WHERE channel_id = ?',
      [channel.id]
    );

    if (!ticket) {
      maria.release();
      return this.replyError(interaction, 'This is not a valid ticket.');
    }

    try {
      channel.permissionOverwrites.delete(ticket.customer_id);
    } catch (error) {}

    try {
      channel.setName(
        `closed-${ticket.ticket_number.toString().padStart(4, '0')}`
      );
    } catch (error) {}

    const initialMessage = await interaction.channel?.messages.fetch(
      ticket.initial_message_id
    );
    const reopenedMessage = await interaction.channel?.messages.fetch(
      ticket.reopened_message_id
    );
    if (initialMessage) {
      await initialMessage.edit({
        components: [],
      });
    }
    if (reopenedMessage) {
      await reopenedMessage.delete();
    }

    await interaction.editReply({
      embeds: [
        createEmbed({
          theme: 'success',
          title: `${emojis.checkmark} Ticket Closed`,
          text: 'Please click "Dismiss Message" below.',
        }),
      ],
      components: [],
    });

    let closedMessage = null;
    if (interaction.message.channel.isSendable()) {
      closedMessage = await interaction.message.channel.send({
        embeds: [
          createEmbed({
            theme: 'success',
            title: `${emojis.checkmark} Ticket Closed`,
            text: `The ticket has been closed. Please do not delete this channel until the transcript has been saved!`,
          }),
        ],
        components: [
          new ActionRowBuilder<ButtonBuilder>().addComponents(
            // new ButtonBuilder({
            //   customId: 'reopen-ticket',
            //   label: 'Reopen',
            //   style: ButtonStyle.Secondary,
            // }),
            // new ButtonBuilder({
            //   customId: 'save-ticket',
            //   label: 'Save Transcript',
            //   style: ButtonStyle.Secondary,
            // }),
            new ButtonBuilder({
              customId: 'delete-ticket',
              label: 'Delete',
              style: ButtonStyle.Secondary,
              disabled: true,
            })
          ),
        ],
      });
    }

    await maria.query(
      'UPDATE support_tickets SET closed_at = NOW(), closed_message_id = ?, closed_by = ? WHERE channel_id = ?',
      [closedMessage?.id, interaction.user.id, channel.id]
    );

    maria.release();

    const uuid = await saveTranscript(
      interaction.client,
      interaction.channelId
    );
    if (closedMessage) {
      await closedMessage.edit({
        embeds: [
          createEmbed({
            theme: 'success',
            title: `${emojis.checkmark} Ticket Closed`,
            text: `The ticket has been closed.`,
          }),
        ],
        components: [
          new ActionRowBuilder<ButtonBuilder>().addComponents(
            // new ButtonBuilder({
            //   customId: 'reopen-ticket',
            //   label: 'Reopen',
            //   style: ButtonStyle.Secondary,
            // }),
            // new ButtonBuilder({
            //   customId: 'save-ticket',
            //   label: 'Save Transcript',
            //   style: ButtonStyle.Secondary,
            // }),
            new ButtonBuilder({
              customId: 'delete-ticket',
              label: 'Delete',
              style: ButtonStyle.Secondary,
              disabled: false,
            }),
            new ButtonBuilder({
              label: 'View Transcript',
              style: ButtonStyle.Link,
              url: `https://trcs.frazers.co/${uuid}`,
            })
          ),
        ],
      });
    }

    const customer = await interaction.guild?.members.fetch(ticket.customer_id);
    const components = [];
    let description =
      interaction.member?.user.id === ticket.customer_id
        ? `Thanks for reaching out to Fortune Frenzy support. It looks like you closed this ticket yourself, so we’re hoping that means everything's sorted. If you need anything else, don’t hesitate to open a new ticket.`
        : `Thanks for contacting Fortune Frenzy support. We’ve gone ahead and closed your ticket, and we hope we were able to help get things sorted. If you have more questions, feel free to open a new one anytime.`;

    if (ticket.staff_id) {
      const staff = await interaction.guild?.members.fetch(ticket.staff_id);
      description += `\n\nOur moderator, **${staff?.user.username}**, assisted you with this ticket. Feel free to leave an optional review by clicking the button below.`;

      components.push(
        new ButtonBuilder({
          customId: `review-ticket-${ticket.id}`,
          label: 'Review',
          emoji: '⭐',
          style: ButtonStyle.Secondary,
        })
      );
    }

    if (uuid) {
      components.push(
        new ButtonBuilder({
          label: 'View Transcript',
          style: ButtonStyle.Link,
          url: `https://trcs.frazers.co/${uuid}`,
        })
      );
    }

    if (customer) {
      await customer.send({
        embeds: [
          createEmbed({
            theme: 'success',
            title: `Your ticket (#${ticket.ticket_number.toString().padStart(4, '0')}) has been closed`,
            text: description,
          }),
        ],
        components: [
          new ActionRowBuilder<ButtonBuilder>().addComponents(components),
        ],
      });
    }
  }

  private async closePreConfirm(interaction: ButtonInteraction) {
    await interaction.reply({
      embeds: [
        createEmbed({
          theme: 'failure',
          title: `${emojis.nocross} Close Ticket`,
          text: 'Are you sure you want to close this ticket?',
        }),
      ],
      components: [
        new ActionRowBuilder<ButtonBuilder>().addComponents(
          new ButtonBuilder({
            customId: 'confirm-close-ticket',
            label: 'Confirm',
            style: ButtonStyle.Secondary,
          }),
          new ButtonBuilder({
            customId: 'cancel-close-ticket',
            label: 'Cancel',
            style: ButtonStyle.Secondary,
          })
        ),
      ],
      flags: [MessageFlags.Ephemeral],
    });
  }

  private async cancelClose(interaction: ButtonInteraction) {
    await interaction.message.delete();
  }

  private async replyError(interaction: ButtonInteraction, text: string) {
    await interaction.reply({
      embeds: [
        createEmbed({
          theme: 'failure',
          title: `${emojis.nocross} Error`,
          text,
        }),
      ],
      ephemeral: true,
    });
  }
}


==== /interaction-handlers/buttons/tickets/reopenTicketButton.ts ====

import {
  InteractionHandler,
  InteractionHandlerTypes,
} from '@sapphire/framework';
import {
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  GuildMember,
  GuildTextBasedChannel,
  MessageFlags,
  TextChannel,
  type ButtonInteraction,
} from 'discord.js';
import { createEmbed } from '../../../utilities/embed';
import emojis from '../../../utilities/emojis.json' assert { type: 'json' };
import { getMariaConnection } from '../../../services/mariadb';

export class ReopenTicketButton extends InteractionHandler {
  private readonly requiredRole = '1277325690664124428';

  public constructor(
    ctx: InteractionHandler.LoaderContext,
    options: InteractionHandler.Options
  ) {
    super(ctx, {
      ...options,
      interactionHandlerType: InteractionHandlerTypes.Button,
    });
  }

  public override parse(interaction: ButtonInteraction) {
    return interaction.customId === 'reopen-ticket' ? this.some() : this.none();
  }

  public async run(interaction: ButtonInteraction) {
    await interaction.deferUpdate();

    if (!interaction.channel) {
      console.error(
        `[ReopenTicketButton] No channel found for interaction: ${interaction.id}`
      );
      return;
    }

    const member = interaction.member as GuildMember;

    if (!member || !(member instanceof GuildMember)) {
      console.error(
        `[ReopenTicketButton] Invalid member object for interaction: ${interaction.id}`
      );
      return this.replyError(
        interaction,
        'Something went wrong, please try again later.'
      );
    }

    if (!member.roles.cache.has(this.requiredRole)) {
      console.warn(
        `[ReopenTicketButton] Unauthorized attempt to reopen ticket by ${member.user.tag}`
      );
      return this.replyError(
        interaction,
        'Only staff members can reopen tickets.'
      );
    }

    const maria = await getMariaConnection();

    const channel = interaction.channel as TextChannel;
    const [ticket] = await maria.query(
      'SELECT * FROM support_tickets WHERE channel_id = ?',
      [channel.id]
    );

    if (!ticket) {
      console.error(
        `[ReopenTicketButton] No ticket found for channel: ${channel.id}`
      );
      maria.release();
      return this.replyError(
        interaction,
        'Something went wrong, please try again later.'
      );
    }

    const customer = await interaction.guild?.members.fetch(ticket.customer_id);

    const closedMessage = await interaction.channel.messages.fetch(
      ticket.closed_message_id
    );
    const claimedMessage = await interaction.channel.messages.fetch(
      ticket.claimed_message_id
    );
    const reopenedMessage = await interaction.channel.messages.fetch(
      ticket.reopened_message_id
    );
    const initialMessage = await interaction.channel.messages.fetch(
      ticket.initial_message_id
    );

    if (closedMessage) {
      closedMessage.delete();
    }
    if (claimedMessage) {
      claimedMessage.delete();
    }
    if (reopenedMessage) {
      reopenedMessage.delete();
    }

    await maria.query(
      'UPDATE support_tickets SET staff_id = NULL, claimed_at = NULL, closed_at = NULL, closed_message_id = NULL, claimed_message_id = NULL WHERE channel_id = ?',
      [channel.id]
    );

    channel.setName(
      `ticket-${ticket.ticket_number.toString().padStart(4, '0')}`
    );

    await initialMessage.edit({
      components: [
        new ActionRowBuilder<ButtonBuilder>().addComponents(
          new ButtonBuilder()
            .setCustomId('close-ticket')
            .setLabel('Close')
            .setEmoji(emojis.white_nocross)
            .setStyle(ButtonStyle.Secondary),
          new ButtonBuilder()
            .setCustomId('claim-ticket')
            .setLabel('Claim')
            .setEmoji(emojis.white_checkmark)
            .setStyle(ButtonStyle.Secondary)
        ),
      ],
    });

    let newReopenedMessage = null;
    if (customer && channel.isSendable()) {
      await channel.permissionOverwrites.edit(customer, {
        ViewChannel: true,
        SendMessages: true,
        ReadMessageHistory: true,
        AttachFiles: true,
        EmbedLinks: true,
        AddReactions: true,
      });

      newReopenedMessage = await channel.send({
        embeds: [
          createEmbed({
            theme: 'success',
            title: `${emojis.checkmark} Ticket Reopened`,
            text: `The ticket has been reopened.`,
          }),
        ],
      });
    } else if (!customer && channel.isSendable()) {
      console.warn(
        `[ReopenTicketButton] Customer not found for ticket: ${ticket.ticket_number}`
      );
      newReopenedMessage = await channel.send({
        embeds: [
          createEmbed({
            theme: 'success',
            title: `${emojis.checkmark} Ticket Reopened`,
            text: `The ticket has been reopened.`,
            footer: {
              text: `The member who opened the ticket was not found in the server, I've re-opened the ticket anyway.`,
              iconURL: interaction.guild?.iconURL() ?? undefined,
            },
          }),
        ],
      });
    }

    if (newReopenedMessage) {
      await maria.query(
        'UPDATE support_tickets SET reopened_message_id = ? WHERE channel_id = ?',
        [newReopenedMessage.id, channel.id]
      );
    }

    maria.release();
  }

  private async replyError(interaction: ButtonInteraction, text: string) {
    console.error(`[ReopenTicketButton] Error response: ${text}`);
    await interaction.reply({
      embeds: [
        createEmbed({
          theme: 'failure',
          title: `${emojis.nocross} Error`,
          text,
        }),
      ],
      ephemeral: true,
    });
  }
}


==== /interaction-handlers/buttons/tickets/saveTranscriptButton.ts ====

import {
  InteractionHandler,
  InteractionHandlerTypes,
} from '@sapphire/framework';
import {
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  EmbedBuilder,
  GuildMember,
  GuildTextBasedChannel,
  MessageFlags,
  TextChannel,
  type ButtonInteraction,
} from 'discord.js';
import { createEmbed } from '../../../utilities/embed';
import emojis from '../../../utilities/emojis.json' assert { type: 'json' };
import { getMariaConnection } from '../../../services/mariadb';
import saveTranscript from '../../../utilities/tickets/saveTranscript';

export class SaveTranscriptButton extends InteractionHandler {
  private readonly requiredRole = '1277325690664124428';

  public constructor(
    ctx: InteractionHandler.LoaderContext,
    options: InteractionHandler.Options
  ) {
    super(ctx, {
      ...options,
      interactionHandlerType: InteractionHandlerTypes.Button,
    });
  }

  public override parse(interaction: ButtonInteraction) {
    return interaction.customId === 'save-ticket' ? this.some() : this.none();
  }

  public async run(interaction: ButtonInteraction) {
    const maria = await getMariaConnection();

    const [transcript] = await maria.query(
      'SELECT * FROM ticket_transcripts WHERE related_channel_id = ?',
      [interaction.channelId]
    );

    if (transcript)
      return this.replyError(
        interaction,
        `Transcript already exists: [View Online](https://transcripts.frazers.co/ticket/${transcript.transcript_id})`
      );

    await interaction.reply({
      embeds: [
        new EmbedBuilder()
          .setDescription(`${emojis.loading} Saving transcript...`)
          .setColor('#738acb'),
      ],
    });

    const uuid = await saveTranscript(
      interaction.client,
      interaction.channelId
    );

    interaction.editReply({
      embeds: [
        createEmbed({
          theme: 'success',
          title: `${emojis.checkmark} Transcript Saved`,
          text: `[View Online](https://trcs.frazers.co/${uuid})`,
        }),
      ],
    });
  }

  private async replyError(interaction: ButtonInteraction, text: string) {
    console.error(`[ReopenTicketButton] Error response: ${text}`);
    await interaction.reply({
      embeds: [
        createEmbed({
          theme: 'failure',
          title: `${emojis.nocross} Error`,
          text,
        }),
      ],
      ephemeral: true,
    });
  }
}


==== /interaction-handlers/buttons/tickets/reviewTicketButton.ts ====

import {
  InteractionHandler,
  InteractionHandlerTypes,
} from '@sapphire/framework';
import {
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  EmbedBuilder,
  GuildMember,
  GuildTextBasedChannel,
  MessageFlags,
  ModalBuilder,
  TextChannel,
  TextInputBuilder,
  TextInputStyle,
  type ButtonInteraction,
} from 'discord.js';
import { createEmbed } from '../../../utilities/embed';
import emojis from '../../../utilities/emojis.json' assert { type: 'json' };
import { getMariaConnection } from '../../../services/mariadb';
import saveTranscript from '../../../utilities/tickets/saveTranscript';

export class SaveTranscriptButton extends InteractionHandler {
  private readonly requiredRole = '1277325690664124428';

  public constructor(
    ctx: InteractionHandler.LoaderContext,
    options: InteractionHandler.Options
  ) {
    super(ctx, {
      ...options,
      interactionHandlerType: InteractionHandlerTypes.Button,
    });
  }

  public override parse(interaction: ButtonInteraction) {
    return interaction.customId.startsWith('review-ticket-')
      ? this.some()
      : this.none();
  }

  public async run(interaction: ButtonInteraction) {
    const ticketId = interaction.customId.split('-')[2];
    const maria = await getMariaConnection();

    const [ticket] = await maria.query('SELECT * FROM support_tickets WHERE id = ?', [
      ticketId,
    ]);

    if (!ticket) {
      maria.release();
      return this.replyError(interaction, 'Ticket not found');
    }

    const [review] = await maria.query(
      'SELECT * FROM support_ticket_ratings WHERE ticket_id = ?',
      [ticketId]
    );

    if (review) {
      maria.release();
      return this.replyError(
        interaction,
        'You have already reviewed this ticket'
      );
    }

    maria.release();
    await interaction.showModal(
      new ModalBuilder()
        .setCustomId(`review-ticket-modal-${ticketId}`)
        .setTitle('Review Ticket')
        .addComponents(
          new ActionRowBuilder<TextInputBuilder>().addComponents(
            new TextInputBuilder()
              .setCustomId('rating')
              .setLabel('How would you rate the support you received?')
              .setStyle(TextInputStyle.Short)
              .setMinLength(1)
              .setMaxLength(1)
              .setPlaceholder('1-5')
          ),
          new ActionRowBuilder<TextInputBuilder>().addComponents(
            new TextInputBuilder()
              .setCustomId('comment')
              .setLabel('Do you have any comments?')
              .setStyle(TextInputStyle.Paragraph)
              .setMinLength(1)
              .setPlaceholder('Optional')
          )
        )
    );
  }

  private async replyError(interaction: ButtonInteraction, text: string) {
    console.error(`[ReopenTicketButton] Error response: ${text}`);
    await interaction.reply({
      embeds: [
        createEmbed({
          theme: 'failure',
          title: `${emojis.nocross} Error`,
          text,
        }),
      ],
      ephemeral: true,
    });
  }
}


==== /interaction-handlers/buttons/tickets/deleteTicketButton.ts ====

import {
    InteractionHandler,
    InteractionHandlerTypes,
  } from '@sapphire/framework';
  import {
    ActionRowBuilder,
    ButtonBuilder,
    ButtonStyle,
    EmbedBuilder,
    GuildMember,
    GuildTextBasedChannel,
    MessageFlags,
    ModalBuilder,
    TextChannel,
    TextInputBuilder,
    TextInputStyle,
    type ButtonInteraction,
  } from 'discord.js';
  import { createEmbed } from '../../../utilities/embed';
  import emojis from '../../../utilities/emojis.json' assert { type: 'json' };
  import { getMariaConnection } from '../../../services/mariadb';
  import saveTranscript from '../../../utilities/tickets/saveTranscript';
  
  export class SaveTranscriptButton extends InteractionHandler {
    private readonly requiredRole = '1277325690664124428';
  
    public constructor(
      ctx: InteractionHandler.LoaderContext,
      options: InteractionHandler.Options
    ) {
      super(ctx, {
        ...options,
        interactionHandlerType: InteractionHandlerTypes.Button,
      });
    }
  
    public override parse(interaction: ButtonInteraction) {
      return interaction.customId === 'delete-ticket' ? this.some() : this.none();
    }
  
    public async run(interaction: ButtonInteraction) {
      await interaction.channel?.delete();
    }
  }
  